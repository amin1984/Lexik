<?php

namespace Satisfactory\CronBundle\Repository;

use Doctrine\ORM\EntityRepository;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Satisfactory\CronBundle\Repository\parseCSV;
use Satisfactory\CronBundle\Entity\Cronexecution;

use Symfony\Component\Translation\Translator;
use Symfony\Component\Translation\MessageSelector;

// FTP and SFTP classes
use Satisfactory\CronBundle\Repository\SFTP;
use Sinner\Phpseclib\Net\Net_SFTP;
/**
* CronRepository
*
* This class was generated by the Doctrine ORM. Add your own custom
* repository methods below.
*/
class CronRepository extends Controller
{

    public static function createDirStructure($dealing,$destinationDir,$dateInitexecution)
    {
        if(!is_dir($destinationDir.$dateInitexecution.'-D'.$dealing->getId())){
            //Directory does not exist, so lets create it.
            if(mkdir($destinationDir.$dateInitexecution.'-D'.$dealing->getId(), 0775, true)) {
                return $destinationDir.$dateInitexecution.'-D'.$dealing->getId().'/';
            }
        }
        return false;
    }

    public static function generateTmpFileNameOriginal($filename,$id_dealing)
    {
        $ext = pathinfo($filename, PATHINFO_EXTENSION);
        return $new_filename = date('Y.m.d.H.i.s',time())."-d".$id_dealing.".".$ext;

    }

    public static function getFileContent($filename)
    {
        if(!file_exists($filename)) {
            return false;
        }
        return file_get_contents($filename);

    }



    public static function parseCSVFile($filename,$dealing)
    {
        if(!file_exists($filename)) {
            return false;
        }
        $handle     = fopen($filename,"r"); 
        $matrix     = array();
        $lineNumber = 0; 
        $header     = "";
        $rowCount   = 0;
        
        while (($row = fgetcsv($handle, 0, self::GetCsvSeparatorFromDealing($dealing))) !== FALSE)
        {
            if($lineNumber == 0) 
            {
                $header = $row;
                if($dealing->getEncoding() == "UTF8-sans BOM") {
                    $header = array_map("self::remove_utf8_bom", $header);
                }
            }
            
            foreach($row as $key => $cell)
            {
                $row[$key] = trim($cell);
            }
            $matrix[] = @array_combine($header, array_values($row));

            $lineNumber++;
        }
        ######### clean the array from the empty rows (rows where not corresponding to the header structure or have a syntax error )
        foreach ($matrix as $key =>$val) {
            if(!$val) {
                unset($matrix[$key]);
                //                return false;
            }
        }
        array_shift($matrix);
        if(empty($matrix)) {
            foreach ($header as $k=>$v) {
                $matrix[0][$v] = "";
            }
        }
        
        return $matrix;

    }


    public static function parseFile($filename)
    {
        if(!file_exists($filename)) {
            return false;
        }
        $handle = fopen($filename,"r"); 
        $matrix = array();
        $lineNumber = 0; 
        while (($row = fgets($handle)) !== FALSE)
        {
            $matrix[] = trim($row);

            $lineNumber++;
        }
        return $matrix;
    }

    public static function checkEncodage($file) {
        $string = file_get_contents($csv_file);
        return mb_detect_encoding($string, 'UTF-8', true);
    }

    public static function remove_utf8_bom($text)
    {
        $bom = pack('H*','EFBBBF');
        $text = preg_replace("/^$bom/", '', $text);
        return $text;
    }

    public static function genrateCsvFormat($content,$putHeader = true)
    {
        if(!$content) {
            return false;
        }
        $return = array();

        $header=  array_keys($content[0]);
        if($putHeader)
            $return[] = $header;
        if(count($content)>0 && (implode($content[0])!="")) {
            foreach ($content as $row) {
                $return[] = $row;
            }
        }
        return $return;
    }

    public static function gerateFolderForDealingExecution ($dealing) 
    {

    }


    public static function GetCsvSeparatorFromDealing ($dealing)
    {
        if(!$dealing)
            return ",";
        if($dealing->getSepa() != null || $dealing->getSepa() !="autre")
            return $dealing->getSepa();
        if($dealing->getOther() != null)
            return $dealing->getOther();
        return ",";
    }

    /*
    * Inserts a new key/value after the key in the array.
    *
    * @param $key
    *   The key to insert after.
    * @param $array
    *   An array to insert in to.
    * @param $new_key
    *   The key to insert.
    * @param $new_value
    *   An value to insert.
    *
    * @return
    *   The new array if the key exists, FALSE otherwise.
    *
    * @see array_insert_before()
    */
    public static function arrayIinsertAfter($key, $array, $new_key, $new_value)
    {
        if (array_key_exists($key, $array)) {
            $new = array();
            foreach ($array as $k => $value) {
                $new[$k] = $value;
                if ($k === $key) {
                    $new[$new_key] = $new_value;
                }
            }
            return $new;
        }
        return FALSE;
    }

    /*
    * test FTP or SFTP access 
    * @return
    *   The FTP / SFTP object and connect to the ftp, FALSE otherwise.
    */
    public static function connectFtpSftp($type, $host, $login, $password,$port)
    {
        if($type=="sftp") {
            $ftp = @new Net_SFTP($host,$port);
            $conn_ftp = @$ftp->login($login, $password);
        }
        else {
            $ftp = new SFTP($host,$login , $password,$port); 
            $conn_ftp = @$ftp->connect();
        }
        if (!$conn_ftp) {
            return false;
        }
        return $ftp;
    }

    /*
    * delete file from ftp / sftp
    * @return
    *   boolean
    */
    public static function deleteFileFromFtp($dealing)
    {

        $ftp = CronRepository::connectFtpSftp($dealing->getProtocol(), $dealing->getHost(), $dealing->getLogin(), $dealing->getPassword(), $dealing->getPort());
        if($ftp) {
            $ftpDirectory = $dealing->getDirectory();
            if(substr($ftpDirectory, -1) !='/')
                $ftpDirectory.='/';
            $filename = $ftpDirectory.$dealing->getFileName();
            return $ftp->delete($filename);
        }
    }

    /*
    * test if given file exists in the given ftp (opened connection).
    * @return
    *   The true if file exists. False otherwise
    */
    public static function fileExistsInFtpSftp($type, $ftp, $dir,$file)
    {
        $tmpFile = "/home/www/www.celaneo.com/subdomains/etl_satisfactory/httpdocs/web/uploads/tmp/tmp".rand(1,100).".csv";
        $ftpDirectory = $dir;
        if(substr($ftpDirectory, -1) !='/')
            $ftpDirectory.='/';

        if(!is_dir("/home/www/www.celaneo.com/subdomains/etl_satisfactory/httpdocs/web/uploads/tmp")){
            mkdir("/home/www/www.celaneo.com/subdomains/etl_satisfactory/httpdocs/web/uploads/tmp", 0775, true);
        }
        $file = CronRepository::convertHorodate($file);
        //echo "CONVERTED FILENAME : ".$file."\r\n";
        if(@$ftp->get($ftpDirectory.$file, $tmpFile)) { 
            return $tmpFile;
        }
        return false;

    }

    public static function csvCkeck($filename,$separator = ",",$headerFromFile = array(),$dealing,$deleteFile= true)
    {
        if(!file_exists($filename)) {
            return false;
        }
        
        if(!is_dir('/home/www/www.celaneo.com/subdomains/etl_satisfactory/httpdocs/web/uploads/tmp/')){
            //Directory does not exist, so lets create it.
            mkdir('/home/www/www.celaneo.com/subdomains/etl_satisfactory/httpdocs/web/uploads/tmp/', 0775, true);
        }
        $fileTmp = '/home/www/www.celaneo.com/subdomains/etl_satisfactory/httpdocs/web/uploads/tmp/'.rand(1, 1000).".csv";
        print_r($fileTmp);
        copy($filename,$fileTmp);
        echo "\n aprÃ¨s copie\n";
        $filename   = $fileTmp;
        $handle     = fopen($filename,"r+"); 
        $matrix     = array();
        $lineNumber = 0; 
        $header     = "";
        

        $f = $filename;
        if(is_object($dealing)) {
            
            //data is coming from existing dealing. So we have to treat is as object
            if($dealing->getNbLigneToDelete() > 0) {
                //delete X column from the original file
                $countLines = 1;
                if ($handle) {
                    $lines = file($f);
                    if($lines) 
                    {
                        for ($i = 0;$i < $dealing->getNbLigneToDelete();$i++) 
                        {
                            unset($lines[$i]);
                        }
                    }
                    array_values($lines);
                    file_put_contents($f, $lines);
                } else {
                    return false;
                }

            }


            if($dealing->getDeleteSemicolon() > 0) {
                // if "suppression du ; final dans l'en-tete" is checked then we have to delete it from the first line of the file (from the header)

                $lines = file($f);
                $lines[0] = preg_replace( "/\r|\n/", "", $lines[0] );
                if(substr($lines[0], -1) ==';')
                    $lines[0] = substr($lines[0],0, -1);

                $lines[0].="\n";
                file_put_contents($f, $lines);
            }

            if($dealing->getIsFileheader() > 0) {
                //  if the file does not contain a header so we must take the colums and insert it to the file as a header
                $headerFile = explode(";", $dealing->getFileheader());
                $headerFile = implode(CronRepository::GetCsvSeparatorFromDealing($dealing), $headerFromFile);
                $headerFile.="\n";
                $headerFileArray[] = $headerFile;

                $lines = file($f);
                $lines = array_merge($headerFileArray,$lines);
                file_put_contents($f, $lines);

            }
        }
        else {
            echo 'is_arrray';
            // data coming rom form so we have to treat it as array
            if($dealing['nbLigneToDelete'] > 0) {
                //delete X column from the original file
                $countLines = 1;
                if ($handle) {
                    $lines = file($f);
                    if($lines) {
                        for ($i = 0;$i < $dealing['nbLigneToDelete'];$i++) {
                            unset($lines[$i]);
                        }
                    }
                    array_values($lines);
                    file_put_contents($f, $lines);
                } else {
                    return false;
                }

            }


            if(isset($dealing['deleteSemicolon']) && $dealing['deleteSemicolon'] > 0) {
                // if "suppression du ; final dans l'en-tete" is checked then we have to delete it from the first line of the file (from the header)

                $lines = file($f);
                $lines[0] = preg_replace( "/\r|\n/", "", $lines[0] );
                if(substr($lines[0], -1) ==';')
                    $lines[0] = substr($lines[0],0, -1);

                $lines[0].="\n";
                file_put_contents($f, $lines);
            }

            if(isset($dealing['isFileheader']) && $dealing['isFileheader'] > 0) {
                //  if the file does not contain a header so we must take the colums and insert it to the file as a header
                $headerFile = explode(";", $dealing['fileheader']);
                $headerFile = implode($separator, $headerFromFile);
                $headerFile.="\n";
                $headerFileArray[] = $headerFile;

                $lines = file($f);
                $lines = array_merge($headerFileArray,$lines);
                file_put_contents($f, $lines);

            }
        }



        while (($row = @fgetcsv($handle, 0, $separator)) !== FALSE)
        {
            if(empty($header)) 
            {
                if($lineNumber == 0) 
                {
                    $header = $row;
                    
                }
                
            }

            $matrix[] = @array_combine($header, array_values($row));

            $lineNumber++;

        }
        
        $lines = array();

        foreach ($matrix as $key =>$val) {
            if(!$val) {
                $lines[] = $key+1;
            }
        }
        // delete the temp file
        if($deleteFile)
            unlink($filename);
        return implode(', ', $lines);

    }



    public static function csvGetColumns($filename,$dealing,$deleteFile= true)
    {
        if(!file_exists($filename)) {
            return false;
        }
        $handle = fopen($filename,"r"); 
        $matrix = array();
        $lineNumber = 0; 
        $header = "";
        $separator = self::GetCsvSeparatorFromDealing($dealing);
        $headerFromFile = array();
        if($dealing->getFileHeader() && $dealing->getIsFileHeader() == 1)
            $headerFromFile = explode (";", $dealing->getFileHeader());

        if(!empty($headerFromFile)) {
            $header = $headerFromFile;
            return $header;
        }

        $f = $filename;

        if($dealing->getNbLigneToDelete() > 0) {
            //delete X column from the original file
            $countLines = 1;
            if ($handle) {
                $lines = file($f);
                if($lines) {
                    for ($i = 0;$i < $dealing->getNbLigneToDelete();$i++) {
                        unset($lines[$i]);
                    }
                }
                array_values($lines);
                file_put_contents($f, $lines);
            } else {
                return false;
            }

        }


        if($dealing->getDeleteSemicolon() > 0) {
            // if "suppression du ; final dans l'en-tete" is checked then we have to delete it from the first line of the file (from the header)

            $lines = file($f);
            $lines[0] = preg_replace( "/\r|\n/", "", $lines[0] );
            if(substr($lines[0], -1) ==';')
                $lines[0] = substr($lines[0],0, -1);

            $lines[0].="\n";
            file_put_contents($f, $lines);
        }


        while (($row = @fgetcsv($handle, 0, $separator)) !== FALSE)
        {
            if(empty($header)) {
                if($lineNumber == 0) {
                    $header = $row;
                }
            }
            return $header;
        }

        fclose($handle);
        if($deleteFile)
            unlink($filename);
        return false;

    }


    static public function convertHorodate($string) 
    {
        if( strpos($string, '[') !== FALSE )
        {
            preg_match_all("/(?<=\[).+?(?=\])/", $string, $columns);            
            if($columns) 
            {
                $date = new \DateTime();
                foreach ($columns[0] as $col) 
                {
                    $originalString = $col;
                    $daysPlus = 0;
                    $daysMinus = 0;
                    
                    if( strpos($col, 'J+') !== FALSE )
                    {
                        preg_match('/.+?(J\+(\d+))/', $col, $match);
                        if(isset($match)) 
                        {
                            if(isset($match[2])) {
                                $daysPlus = $match[2];
                                $date = new \DateTime();
                                $date->modify('+'.$daysPlus.' day');
                                $col = str_replace(':J+'.$daysPlus,'',$col);
                                $col = str_replace('JJ',$date->format('d'),$col);
                            }
                        }
                    }
                    
                    if( strpos($col, 'J-') !== FALSE )
                    {
                        preg_match('/.+?(J\-(\d+))/', $col, $match);
                        if(isset($match)) 
                        {
                            if(isset($match[2])) {
                                $daysMinus = $match[2];
                                $date = new \DateTime();
                                $date->modify('-'.$daysMinus.' day');
                                $col = str_replace(':J-'.$daysMinus,'',$col);
                                $col = str_replace('JJ',$date->format('d'),$col);
                            }
                        }
                    }
                    
                    if( strpos($col, 'AAAA') !== FALSE )
                    {
                        $col    = str_replace('AAAA',$date->format('Y'),$col);    
                    }
                    if( strpos($col, 'AA') !== FALSE )
                    {
                        $col    = str_replace('AA',$date->format('y'),$col);
                    }
                    
                    if( strpos($col, 'MM') !== FALSE )
                    {
                        $col    = str_replace('MM',$date->format('m'),$col);
                    }
                    
                    if( strpos($col, 'JJ') !== FALSE )
                    {
                        $col    = str_replace('JJ',date('d'),$col);
                    }

                    $string = str_replace($originalString,$col,$string);    

                }
            }
        }
        $string = str_replace('[','',$string);
        $string = str_replace(']','',$string);
        
        return $string;

    }

    static public function executewildcards ($stringToCompare,$stringWithWildcard) {
          
        //contient
        // include if stringToCompare contains stringWithWildcard
        if(self::startsWith($stringWithWildcard,'*') && self::endsWith($stringWithWildcard,'*')) {
            $stringWithWildcard = substr($stringWithWildcard, 1);
            $stringWithWildcard = substr($stringWithWildcard,0,-1);
            $pos = strpos(strtolower($stringToCompare), strtolower($stringWithWildcard));
            return $pos === false ? false : true;
        }
        //commence par
        if (self::endsWith($stringWithWildcard,'*') && !self::startsWith($stringWithWildcard,'{{!')) { 
            $stringWithWildcard = substr($stringWithWildcard,0,-1);
            return self::startsWith(strtolower($stringToCompare),strtolower($stringWithWildcard));

        }
        //termine par
        if (self::startsWith($stringWithWildcard,'*') && !self::endsWith($stringWithWildcard,'}}') ) { 
            $stringWithWildcard = substr($stringWithWildcard,1);
            return self::endsWith(strtolower($stringToCompare),strtolower($stringWithWildcard));

        }
        //ne commence pas par
        if (self::startsWith($stringWithWildcard,'{{!') && self::endsWith($stringWithWildcard,'}}*') ) { 
            $stringWithWildcard = substr($stringWithWildcard, 3);
            $stringWithWildcard = substr($stringWithWildcard,0,-3);
            return !self::startsWith(strtolower($stringToCompare),strtolower($stringWithWildcard));

        }
        //ne termine pas par
        if (self::startsWith($stringWithWildcard,'*{{!') && self::endsWith($stringWithWildcard,'}}') ) { 
            $stringWithWildcard = substr($stringWithWildcard, 4);
            $stringWithWildcard = substr($stringWithWildcard,0,-2);
            return !self::endsWith(strtolower($stringToCompare),strtolower($stringWithWildcard));

        }
        // include IF "ne contient pas"
        if (self::startsWith($stringWithWildcard,'{{!*') && self::endsWith($stringWithWildcard,'*}}') ) { 
            // Filter is a "does not contain"
            echo "ne contient pas--------".$stringWithWildcard."----------".$stringToCompare."\r\n";
            $stringWithWildcard = substr($stringWithWildcard, 4);
            $stringWithWildcard = substr($stringWithWildcard,0,-3);
            
            $pos = strpos(strtolower($stringToCompare), strtolower($stringWithWildcard));

            return $pos === false ? true : false;

        }
        
        // toto*tata*titi
        if(strpos($stringWithWildcard, '*')) {
            $str  = $stringWithWildcard;
            $str = str_replace("~*","~~",$str);
            $keywords = preg_split("/[\*]+/", $str);
            $contain = true;
            if($keywords) {
                foreach ($keywords as $string) {
                    if($string != "") {
                        $string = str_replace("~~","*",$string);
                        $pos = strpos(strtolower($stringToCompare), strtolower($string));
                        $contain = $pos === false ? false : true;
                    }
                }
            }
            return $contain;
        }

        // if non of the conditions above exists, then we make a simple compare
        return $stringToCompare == $stringWithWildcard;

    }


    static public function startsWith($haystack, $needle) {
        // search backwards starting from haystack length characters from the end
        return $needle === "" || strrpos($haystack, $needle, -strlen($haystack)) !== false;
    }

    static public function endsWith($haystack, $needle) {
        // search forward starting from end minus needle length characters
        return $needle === "" || (($temp = strlen($haystack) - strlen($needle)) >= 0 && strpos($haystack, $needle, $temp) !== false);
    }

    static public function str_replace_first($from, $to, $subject)
    {
        $from = '/'.preg_quote($from, '/').'/';

        return preg_replace($from, $to, $subject, 1);
    }

    /*
     * detect if the given array contain barkets,if true it put the strings inside 
     * those barkets into array and return it, else return NULL
     */
    static public function detectBracket($array)
    {
        array_walk_recursive(
                    $array,
                    function($val, $key) use (&$cols) {
                        if( strpos($val, '[') !== FALSE )
                        {
                            preg_match_all("/(?<=\[).+?(?=\])/", $val, $columns); 
                            if( isset($columns) )
                            {
                                foreach ($columns[0] as $c) 
//                                    print_r($columns);
                                    $cols[]= $c;
                            }
                        }
                    }
                );
        return $cols;
         
    }

    /*
     * replace columns names (that are inside the barkets []) with the current value from $fileContentRow
     *  (this include the date replacement)
     */
    static public function replaceBracket($filtreCorrespondance,$fileContentRow,$columns)
    {
        array_walk_recursive(
                    $filtreCorrespondance,
                    function(&$value) use (&$columns,&$fileContentRow) {
                        if($columns) {
                            foreach ($columns as $c) {
                                $value = str_replace('['.$c.']',@$fileContentRow[$c],$value);
                            }
                        }
                        $value = CronRepository::convertHorodate($value);
                    }
                );
        return $filtreCorrespondance;
         
    }
    

    
    
}
